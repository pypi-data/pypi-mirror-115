{"version":3,"sources":["webpack://jupyterlab-unfold/./lib/index.js","webpack://jupyterlab-unfold/./lib/unfold.js","webpack://jupyterlab-unfold/./style/icons/folder-open.svg"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAA8D;AACJ;AACN;AACgB;AACd;AACP;AACwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wEAAmB;AACjC,eAAe,oEAAgB,EAAE,gEAAW;AAC5C,eAAe,yDAAQ;AACvB;AACA,4BAA4B,+DAAa,EAAE,YAAY;AACvD,mDAAmD;AACnD;AACA,8BAA8B,+DAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,oDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,6BAA6B,+DAAa;AAC1C,kBAAkB,8DAAO;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,gBAAgB;AAChB;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtEzB;AACsD;AACR;AACM;AACc;AACd;AACJ;AAC0C;AACtC;AACpD;AAC8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,8DAAO;AACzC;AACA,YAAY,iEAAgB;AAC5B,CAAC;AACD;AACA;AACA;AACO,+BAA+B,wEAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAoB;AACtD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sCAAsC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,+DAAU;AAC9C;AACA,4CAA4C,aAAa,gDAAgD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sEAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAqB;AAC3C;AACA;AACA,yBAAyB,0DAAO;AAChC;AACA;AACA;AACA;AACA,yBAAyB,kEAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAgB;AACzC,4BAA4B,+DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA,iBAAiB,sEAAgB;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,sEAAuB,gBAAgB,gEAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yCAAyC,2EAAsB;AACtE;AACA;AACA,+BAA+B,8DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,gEAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/ZA,iEAAe,seAAse,E","file":"lib_index_js.fb48d433773b4955c5da.js","sourcesContent":["import { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { addIcon } from '@jupyterlab/ui-components';\nimport { WidgetTracker, ToolbarButton } from '@jupyterlab/apputils';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { IStateDB } from '@jupyterlab/statedb';\nimport { FileTreeBrowser, FilterFileTreeBrowserModel } from './unfold';\n/**\n * The extension ID.\n */\nconst EXTENSION_ID = 'jupyterlab-unfold';\n/**\n * The file browser namespace token.\n */\nconst namespace = 'filebrowser';\nconst extension = {\n    id: EXTENSION_ID,\n    provides: IFileBrowserFactory,\n    requires: [IDocumentManager, ITranslator],\n    optional: [IStateDB],\n    activate: async (app, docManager, translator, state) => {\n        const tracker = new WidgetTracker({ namespace });\n        const createFileBrowser = (id, options = {}) => {\n            var _a;\n            const model = new FilterFileTreeBrowserModel({\n                translator: translator,\n                auto: (_a = options.auto) !== null && _a !== void 0 ? _a : true,\n                manager: docManager,\n                driveName: options.driveName || '',\n                refreshInterval: options.refreshInterval,\n                app,\n                state: options.state === null\n                    ? undefined\n                    : options.state || state || undefined\n            });\n            const widget = new FileTreeBrowser({\n                id,\n                model,\n                restore: true,\n                translator,\n                app\n            });\n            // Track the newly created file browser.\n            void tracker.add(widget);\n            return widget;\n        };\n        // Manually restore and load the default file browser.\n        const defaultBrowser = createFileBrowser(EXTENSION_ID, {\n            auto: false,\n            restore: false\n        });\n        // TODO Remove this! Why is this needed?\n        // The @jupyterlab/filebrowser-extension:launcher-toolbar-button extension should take care of this\n        const { commands } = app;\n        const trans = translator.load('jupyterlab');\n        // Add a launcher toolbar item.\n        const launcher = new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                if (commands.hasCommand('launcher:create')) {\n                    return commands.execute('launcher:create');\n                }\n            },\n            tooltip: trans.__('New Launcher'),\n            actualOnClick: true\n        });\n        defaultBrowser.toolbar.insertItem(0, 'launch', launcher);\n        return { createFileBrowser, defaultBrowser, tracker };\n    }\n};\nexport default extension;\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { ArrayExt, toArray } from '@lumino/algorithm';\nimport { ElementExt } from '@lumino/domutils';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { DOMUtils, showErrorMessage } from '@jupyterlab/apputils';\nimport { renameFile } from '@jupyterlab/docmanager';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { DirListing, FileBrowser, FilterFileBrowserModel } from '@jupyterlab/filebrowser';\nimport { LabIcon } from '@jupyterlab/ui-components';\n// @ts-ignore\nimport folderOpenSvgstr from '../style/icons/folder-open.svg';\n/**\n * The class name added to drop targets.\n */\nconst DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The mime type for a contents drag object.\n */\nconst CONTENTS_MIME = 'application/x-jupyter-icontents';\nexport const folderOpenIcon = new LabIcon({\n    name: 'ui-components:folder-open',\n    svgstr: folderOpenSvgstr\n});\n/**\n * A filetree renderer.\n */\nexport class FileTreeRenderer extends DirListing.Renderer {\n    constructor(model) {\n        super();\n        this.model = model;\n    }\n    /**\n     * Create the DOM node for a dir listing.\n     */\n    createNode() {\n        const node = document.createElement('div');\n        const content = document.createElement('ul');\n        content.className = 'jp-DirListing-content';\n        node.appendChild(content);\n        node.tabIndex = 1;\n        return node;\n    }\n    populateHeaderNode(node, translator, hiddenColumns) {\n        // No-op we don't want any header\n    }\n    handleHeaderClick(node, event) {\n        return null;\n    }\n    updateItemNode(node, model, fileType, translator, hiddenColumns) {\n        super.updateItemNode(node, model, fileType, translator, hiddenColumns);\n        if (model.type === 'directory' && this.model.isOpen(model)) {\n            const iconContainer = DOMUtils.findElement(node, 'jp-DirListing-itemIcon');\n            folderOpenIcon.element({\n                container: iconContainer,\n                className: 'jp-DirListing-itemIcon',\n                stylesheet: 'listing'\n            });\n        }\n        // Removing old vbars\n        while (node.firstChild !== null &&\n            node.firstChild.classList.contains('jp-DirListing-vbar')) {\n            node.removeChild(node.firstChild);\n        }\n        // Adding vbars for subdirs\n        for (let n = 0; n < model.path.split('/').length - 1; n++) {\n            const vbar = document.createElement('div');\n            vbar.classList.add('jp-DirListing-vbar');\n            node.insertBefore(vbar, node.firstChild);\n        }\n    }\n}\n/**\n * A widget which hosts a filetree.\n */\nexport class DirTreeListing extends DirListing {\n    constructor(options) {\n        super(Object.assign(Object.assign({}, options), { renderer: new FileTreeRenderer(options.model) }));\n    }\n    get headerNode() {\n        return document.createElement('div');\n    }\n    sort(state) {\n        // @ts-ignore\n        this._sortedItems = toArray(this.model.items());\n        // @ts-ignore\n        this._sortState = state;\n        this.update();\n    }\n    get model() {\n        // @ts-ignore\n        return this._model;\n    }\n    async handleFileSelect(event) {\n        super.handleFileSelect(event);\n        if (Object.keys(this.selection).length === 1) {\n            const selection = Object.keys(this.selection)[0];\n            const entry = await this.model.getEntry(selection);\n            if (entry.type === 'directory') {\n                this.model.path = '/' + selection;\n                this.model.toggle(entry.path);\n            }\n            else {\n                this.model.path = '/' + PathExt.dirname(selection);\n            }\n        }\n    }\n    _eventDragEnter(event) {\n        if (event.mimeData.hasData(CONTENTS_MIME)) {\n            // @ts-ignore\n            const index = this._hitTestNodes(this._items, event);\n            let target;\n            if (index !== -1) {\n                // @ts-ignore\n                target = this._items[index];\n            }\n            else {\n                target = event.target;\n            }\n            target.classList.add(DROP_TARGET_CLASS);\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    _eventDragOver(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const dropTarget = DOMUtils.findElement(this.node, DROP_TARGET_CLASS);\n        if (dropTarget) {\n            dropTarget.classList.remove(DROP_TARGET_CLASS);\n        }\n        // @ts-ignore\n        const index = this._hitTestNodes(this._items, event);\n        let target;\n        if (index !== -1) {\n            // @ts-ignore\n            target = this._items[index];\n        }\n        else {\n            target = event.target;\n        }\n        target.classList.add(DROP_TARGET_CLASS);\n    }\n    _eventDrop(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // @ts-ignore\n        clearTimeout(this._selectTimer);\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        if (!event.mimeData.hasData(CONTENTS_MIME)) {\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Get the path based on the target node.\n        // @ts-ignore\n        const index = ArrayExt.firstIndexOf(this._items, target);\n        let newDir;\n        if (index !== -1) {\n            const item = toArray(this.model.items())[index];\n            if (item.type === 'directory') {\n                newDir = item.path;\n            }\n            else {\n                newDir = PathExt.dirname(item.path);\n            }\n        }\n        else {\n            newDir = '';\n        }\n        // @ts-ignore\n        const manager = this._manager;\n        // Handle the items.\n        const promises = [];\n        const paths = event.mimeData.getData(CONTENTS_MIME);\n        if (event.ctrlKey && event.proposedAction === 'move') {\n            event.dropAction = 'copy';\n        }\n        else {\n            event.dropAction = event.proposedAction;\n        }\n        for (const path of paths) {\n            const localPath = manager.services.contents.localPath(path);\n            const name = PathExt.basename(localPath);\n            const newPath = PathExt.join(newDir, name);\n            // Skip files that are not moving.\n            if (newPath === path) {\n                continue;\n            }\n            if (event.dropAction === 'copy') {\n                promises.push(manager.copy(path, newDir));\n            }\n            else {\n                promises.push(renameFile(manager, path, newPath));\n            }\n        }\n        Promise.all(promises).catch(error => {\n            void showErrorMessage(\n            // @ts-ignore\n            this._trans._p('showErrorMessage', 'Error while copying/moving files'), error);\n        });\n    }\n    _hitTestNodes(nodes, event) {\n        return ArrayExt.findFirstIndex(nodes, node => ElementExt.hitTest(node, event.clientX, event.clientY) ||\n            event.target === node);\n    }\n    handleEvent(event) {\n        switch (event.type) {\n            case 'lm-dragenter':\n                this._eventDragEnter(event);\n                break;\n            case 'lm-dragover':\n                this._eventDragOver(event);\n                break;\n            case 'lm-drop':\n                this._eventDrop(event);\n                break;\n            default:\n                super.handleEvent(event);\n                break;\n        }\n    }\n}\n/**\n * Filetree browser model with optional filter on element.\n */\nexport class FilterFileTreeBrowserModel extends FilterFileBrowserModel {\n    constructor(options) {\n        super(options);\n        this._isRestored = new PromiseDelegate();\n        this._savedState = null;\n        this._stateKey = null;\n        this._path = '.';\n        this.openState = {};\n        this.app = options.app;\n        this.contentManager = this.app.serviceManager.contents;\n        this.basePath = '.';\n        this._savedState = options.state || null;\n    }\n    get path() {\n        return this._path;\n    }\n    set path(value) {\n        this._path = value;\n    }\n    async getEntry(path) {\n        return await this.contentManager.get(path);\n    }\n    /**\n     * Change directory.\n     *\n     * @param path - The path to the file or directory.\n     *\n     * @returns A promise with the contents of the directory.\n     */\n    async cd(pathToUpdate = '.') {\n        const result = await this.fetchContent(this.basePath, pathToUpdate);\n        // @ts-ignore\n        this.handleContents({\n            name: '.',\n            path: '.',\n            type: 'directory',\n            content: result\n        });\n        if (this._savedState && this._stateKey) {\n            void this._savedState.save(this._stateKey, { openState: this.openState });\n        }\n        this.onRunningChanged(this.manager.services.sessions, this.manager.services.sessions.running());\n    }\n    /**\n     * A promise that resolves when the model is first restored.\n     */\n    get restored() {\n        return this._isRestored.promise;\n    }\n    /**\n     * Restore the state of the file browser.\n     *\n     * @param id - The unique ID that is used to construct a state database key.\n     *\n     * @param populate - If `false`, the restoration ID will be set but the file\n     * browser state will not be fetched from the state database.\n     *\n     * @returns A promise when restoration is complete.\n     *\n     * #### Notes\n     * This function will only restore the model *once*. If it is called multiple\n     * times, all subsequent invocations are no-ops.\n     */\n    async restore(id, populate = true) {\n        const { manager } = this;\n        const key = `file-browser-${id}:openState`;\n        const state = this._savedState;\n        const restored = !!this._stateKey;\n        if (restored) {\n            return;\n        }\n        // Set the file browser key for state database fetch/save.\n        this._stateKey = key;\n        if (!populate || !state) {\n            this._isRestored.resolve(undefined);\n            return;\n        }\n        await manager.services.ready;\n        try {\n            const value = await state.fetch(key);\n            if (!value) {\n                await this.cd('.');\n                this._isRestored.resolve(undefined);\n                return;\n            }\n            this.openState = value['openState'];\n            await this.cd('.');\n        }\n        catch (error) {\n            await this.cd('.');\n            await state.remove(key);\n        }\n        this._isRestored.resolve(undefined);\n    }\n    /**\n     * Open/close directories to discover/hide a given path.\n     *\n     * @param pathToToggle - The path to discover/hide.\n     */\n    async toggle(pathToToggle = '.') {\n        this.openState[pathToToggle] = !this.openState[pathToToggle];\n        // Refresh\n        this.cd('.');\n    }\n    /**\n     * Check whether a directory entry is open or not.\n     *\n     * @param model - The given entry.\n     *\n     * @returns Whether the directory is open or not.\n     *\n     */\n    isOpen(model) {\n        return !!this.openState[model.path];\n    }\n    async fetchContent(path, pathToUpdate) {\n        const result = await this.contentManager.get(path);\n        let items = [];\n        const sortedContent = this.sortContents(result.content);\n        this.openState[path] = true;\n        for (const entry of sortedContent) {\n            items.push(entry);\n            if (entry.type !== 'directory') {\n                continue;\n            }\n            const isOpen = (pathToUpdate && pathToUpdate.startsWith('/' + entry.path)) ||\n                this.isOpen(entry);\n            if (isOpen) {\n                const subEntryContent = await this.fetchContent(entry.path, pathToUpdate);\n                items = items.concat(subEntryContent);\n            }\n            else {\n                this.openState[entry.path] = false;\n            }\n        }\n        return items;\n    }\n    /**\n     * Sort the entries\n     *\n     * @param data: The entries to sort\n     * @returns the sorted entries\n     */\n    sortContents(data) {\n        const directories = data.filter(value => value.type === 'directory');\n        const files = data.filter(value => value.type !== 'directory');\n        const sortedDirectories = directories.sort((a, b) => a.name.localeCompare(b.name));\n        const sortedFiles = files.sort((a, b) => a.name.localeCompare(b.name));\n        return sortedDirectories.concat(sortedFiles);\n    }\n    onFileChanged(sender, change) {\n        this.refresh();\n    }\n}\n/**\n * The filetree browser.\n */\nexport class FileTreeBrowser extends FileBrowser {\n    constructor(options) {\n        super(options);\n        this.layout.removeWidget(this.crumbs);\n        this.showLastModifiedColumn = false;\n    }\n    get showLastModifiedColumn() {\n        return false;\n    }\n    set showLastModifiedColumn(value) {\n        if (this.listing.setColumnVisibility) {\n            this.listing.setColumnVisibility('last_modified', false);\n        }\n    }\n    createDirListing(options) {\n        return new DirTreeListing({\n            model: this.model,\n            translator: this.translator\n        });\n    }\n    set useFuzzyFilter(value) {\n        // No-op\n    }\n}\n","export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"16\\\" viewBox=\\\"0 0 576 512\\\"><path class=\\\"jp-icon3 jp-icon-selectable\\\" fill=\\\"#616161\\\" d=\\\"M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z\\\"></path></svg>\\n\";"],"sourceRoot":""}