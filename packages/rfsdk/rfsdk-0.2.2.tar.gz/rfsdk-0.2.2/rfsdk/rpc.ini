#rpc的相关配置
[rpc]
#tracing_plugin=/usr/local/lib/libzipkin_opentracing.so
# tracing 配置
tracing_conf=zipkin_config.json
# 全局tracing开关，0为关闭，其余为打开
open_tracing=1

# consul地址 需要配置成 tcp://x.x.x.x:xxxx
consul_addr=
# consul检测类型 0:ttl 1:http 2:grpc，不设置或其余值，默认为ttl
consul_check_type=0

# 宿主机ip,格式 127.0.0.1,非docker环境，无需配置
host_ip=

# 设置日志级别
# 0-debug 1-info 2-warning 3-error 4-fatal
log_level=0
# 设置日志文件保留个数(目前等同于保留天数)
# 若log_file_max_size不为0，则此配置即为保留天数&文件个数，只要满足其中一个，则删除日志
log_max_files=7
# 设置日志文件最大大小，若此配置不为0，则日志按大小分割，不再按日期,单位为mb
log_file_max_size=0

# 开启冗余日志
# 0-不开启 1-代表只开启请求/应答流 2-代表开启所有;其余值代表关闭
used_verbose_log=2
# 0-代表同步 1-或其余代表异步记录日志
used_verbose_async=1
# 是否精简冗余日志 0-不精简 1-精简
used_reduce_log=0

# 崩溃时是否使用gdb抓取堆栈
# 0-不使用 1&其他-代表使用
used_backtrace_gdb=0

#metrics配置
[metrics]
# prometheus推送地址 tcp://x.x.x.x:xxxx,此为push_gateway的地址
prometheus_addr=
# prometheus pushgateway账户
prometheus_account=admin
# prometheus pushgateway密码
prometheus_pwd=admin
# prometheus 提交频率 单位 s
prometheus_push_interval=5
# 打开推送至monitor服务端开关 0-关闭 1&其余 开启;
# 若打开，请确保monitor服务存在，且当前进程的metrics不会推送至prometheus
# 若关闭，prometheus_addr 配置打开的情况下，当前进程metrics会推送至prometheus
open_push_metrics_to_monitor=1
# monitor推送地址 tcp://x.x.x.x:xxxx, 若为空，则代表使用名字服务，特殊场景下配置
push_monitor_addr=
# prometheus_pull_addr主动获取的地址 http://x.x.x.x:xxxx
prometheus_pull_addr=
# prometheus发送的job实例前缀
prometheus_job_prefix=
# prometheus发送到instance的前缀
prometheus_instance_prefix=

# auth认证文件名，目录与rpc.ini中一致
[auth]
auth_file=auth.yaml

#bus配置
[bus]
# 提供方设置
bind_rpc_router_addr=tcp://*:9009
bind_rpc_pub_addr=tcp://*:9008
bind_rpc_pri_addr=tcp://*:9007
bind_rpc_pull_addr=tcp://*:9001

# 调用者配置
rpc_router_addr=tcp://127.0.0.1:9009
rpc_pub_addr=tcp://127.0.0.1:9008
rpc_pri_addr=tcp://127.0.0.1:9007
rpc_pull_addr=tcp://127.0.0.1:9001

# bus推送响应线程
rpc_push_resp_thread_num=1

# 等待bus进程启动时间，若在相应时间内s_bus未启动，则进程退出，若为0，则无需等待，单位为s
wait_bus_start_time=5

#name_service端口地址
[name_service]
# 名字服务设置
bind_name_service_addr=tcp://*:8091
# 调用名字服务设置
name_service_addr=tcp://127.0.0.1:8091
# 健康检查地址
health_addr=tcp://*:41213
# tcp模式: 是否将上传的ip替换成连接ip，若为0，则表示不替换，否则替换为access_ip
tcp_use_access_ip=0

#client默认配置
[client]
# 请求超时时间 单位 s
request_timeout=5
# 连接超时时间 单位 s, 0表示不设置超时
connect_timeout=5

#daemon默认配置
[daemon]
# daemon服务端口配置
bind_daemon_service_addr=tcp://*:8092|dynamic
# 调用daemon服务设置(一定需要为本地服务)
daemon_service_addr=tcp://127.0.0.1:8092
# 健康检查地址
health_addr=tcp://*:41205
# 退出时是否关闭子程序 0-代表不关闭，其余代表关闭
enable_close_child_process=1
# 是否定时重启被守护的程序 0-代表不定时重启，其余代表重启,时间由各个子服务单独配置
# 此为总开关,若此处配置为0，那么即使配置了时间，也不会被重启
enable_restart_child_process=1
# 检测超时时间 单位 s
daemon_timeout=10
# 子进程超时是否使用pstack抓取堆栈(确保pstack存在)
# 0-不使用 1&其他-代表使用
used_backtrace_pstack=0
