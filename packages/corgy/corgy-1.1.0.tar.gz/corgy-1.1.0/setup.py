# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['corgy', 'tests']

package_data = \
{'': ['*']}

extras_require = \
{'colors': ['crayons>=0.4.0,<0.5.0']}

setup_kwargs = {
    'name': 'corgy',
    'version': '1.1.0',
    'description': 'Elegant command line parsing',
    'long_description': '# corgy\n\nElegant command line parsing for Python.\n\nCorgy allows you to create a command line interface in Python, without worrying about boilerplate code. This results in cleaner, more modular code.\n\n```python\nfrom corgy import Corgy, corgyparser\n\nclass ArgGroup(Corgy):\n    arg1: Annotated[Optional[int], "optional number"]\n    arg2: Annotated[bool, "a boolean"]\n\nclass MyArgs(Corgy):\n    arg1: Annotated[int, "a number"] = 1\n    arg2: Annotated[Sequence[float], "at least one float"]\n    grp1: Annotated[ArgGroup, "group 1"]\n\nargs = MyArgs.parse_from_cmdline()\n```\n\nCompare this to the equivalent code which uses argparse:\n\n```python\nfrom argparse import ArgumentParser, BooleanOptionalAction\n\nparser = ArgumentParser()\nparser.add_argument("--arg1", type=int, help="a number", default=1)\nparser.add_argument("--arg2", type=float, nargs="+", help="at least one float", required=True)\n\ngrp_parser = parser.add_argument_group("group 1")\ngrp_parser.add_argument("--arg3:arg1", type=int, help="optional number")\ngrp_parser.add_argument("--arg3:arg2", help="a boolean", action=BooleanOptionalAction)\n\nargs = parser.parse_args()\n```\n\nCorgy also provides support for more informative help messages from `argparse`, and colorized output:\n\n![Sample output from Corgy](example.png)\n\n# Install\n**`corgy` requires Python 3.9+**. It is available on PyPI, and can be installed with pip:\n\n```bash\npip install corgy\n```\n\nSupport for colorized output requires the `crayons` package, also available on PyPI. You can pull it as a dependency for `corgy` by installing with the `colors` extra:\n\n```bash\npip install corgy[colors]\n```\n\n# Usage\nTo create a command line interface, subclass `Corgy`, and declare your arguments using type annotations.\n\n```python\nclass A(Corgy):\n    x: int\n    y: float\n```\n\nAt runtime, class `A` will have `x`, and `y` as properties, so that the class can be used similar to Python dataclasses.\n\n```python\na = A()\na.x = 1\na.y = a.x + 1.1\n```\n\nFor command line parsing, `x` and `y` are added to an `ArgumentParser` object with the approriate arguments passed to `ArgumentParser.add_argument`. This is roughly equivalent to:\n\n```python\nparser = ArgumentParser()\nparser.add_argument("--x", type=int, required=True)\nparser.add_argument("--y", type=float, required=True)\n```\n\n`Corgy` does not support positional arguments. All arguments are converted to optional arguments, and prefixed with `--`.\n\n## Special annotations\n`Corgy` recognizes a number of special annotations, which are used to control how the argument is parsed.\n\n### Annotated\n`typing.Annotated` can be used to add a help message.\n\n```python\nx: Annotated[int, "help for x"]\n```\n\n`Annotated` can accept multiple arguments, but only the first two are used by `Corgy`. The first argument is the type, and the second is the help message. `Annotated` should always be the outermost annotation; other special annotations should be part of the type.\n\n### Optional\n`typing.Optional` can be used to mark an argument as optional.\n\n```python\nx: Optional[int]\n```\n\nAnother way to mark an argument as optional is to provide a default value.\n\n```python\nx: int = 0\n```\n\nDefault values can be used in conjunction with `Optional`.\n\n```python\nx: Optional[int] = 0\n```\n\nNote that the last two examples are not equivalent, since the type of `x` is `Optional[int]` in the last example, so it is allowed to be `None`.\n\nWhen parsing from the command line, arguments which are not marked as optional (because they are not marked with `Optional`, and don\'t have a default value) will be required.\n\n**Default values are not type checked, and can be arbitrary objects.**\n\n### Sequence\n`collections.abc.Sequence` can be used to specify that an argument accepts multiple space-separated values. `typing.Sequence` can also be used, but is not recommended as it is deprecated since Python 3.9.\n\nThere are a few different ways to use `Sequence`, each resulting in different conditions for the parser. The simplest case is a plain sequence.\n\n```python\nx: Sequence[int]\n```\n\nThis represents a (possibly empty) sequence, and corresponds to the following call to `ArgumentParser.add_argument`.\n\n```python\nparser.add_argument("--x", type=int, nargs="*", required=True)\n```\n\nNote that since the argument is required, parsing an empty list will still require `--x` in the command line. After parsing, `x` will be a `list`. To denote an optional sequence, use `Optional[Sequence[...]]`.\n\nTo specify that a sequence must be non-empty, use:\n\n```python\nx: Sequence[int, ...]\n```\n\nThis will result in `nargs` being set to `+` in the call to `ArgumentParser.add_argument`. Using this syntax **requires** `collections.abc.Sequence`, since `typing.Sequence` does not accept `...` as an argument.\n\nFinally, you can specify a fixed length sequence.\n\n```python\nx: Sequence[int, int, int]\n```\n\nThis amounts to `nargs=3`. All types in the sequence must be the same. So, `Sequence[int, str, int]` will result in a `TypeError`.\n\n### Literal\n`typing.Literal` can be used to specify that an argument takes one of a fixed set of values.\n\n```python\nx: Literal[0, 1, 2]\n```\n\nThe provided values are passed to the `choices` argument of `ArgumentParser.add_argument`. All values must be of the same type, which will be inferred from the type of the first value.\n\n`Literal` itself can be used as a type, for instance inside a `Sequence`.\n\n```python\nx: Sequence[Literal[0, 1, 2], Literal[0, 1, 2]]\n```\n\nThis is a sequence of length 2, where each element is either 0, 1, or 2.\n\n### Bool\n`bool` types (when not in a sequence) are converted to `argparse.BooleanOptionalAction`.\n\n```python\nclass A(Corgy):\n    arg: bool\n\nparser = ArgumentParser()\nA.add_to_parser(parser)\nparser.print_help()\n```\n\n```output\nusage: -c [-h] --arg | --no-arg\n\noptional arguments:\n  -h, --help       show this help message and exit\n  --arg, --no-arg\n```\n\n## Argument Groups\n`Corgy` classes can themselves be used as a type, to represent a group of arguments.\n\n```python\nclass A(Corgy):\n    x: int\n    y: float\n\nclass B(Corgy):\n    x: int\n    grp: Annotated[A, "a group"]\n```\n\nGroup arguments are added to the command line parser with the group argument name prefixed. In the above example, parsing using `B` would result in the arguments `--x`, `--grp:x`, and `--grp:y`. `grp:x` and `grp:y` will be converted to an instance of `A`, and set as the `grp` property of `B`.\n\n## Custom Parsers\nTo use a custom function for parsing an argument, use the `corgy.corgyparser` decorator.\n\n```python\nclass A(Corgy):\n    time: tuple[int, int, int]\n\n    @corgyparser("time")\n    def parse_time(s):\n        return tuple(map(int, s.split(":")))\n```\n\nThe decorated function should accept a single string, and return the parsed value.\n\n## `Corgy` Methods\n`Corgy` subclasses have the following public methods.\n\n### *classmethod* `Corgy.add_args_to_parser(parser: argparse.ArgumentParser, name_prefix: str = "")`\nAdd arguments for the class to the given parser. Options:\n\n* `parser`: The `argparse.ArgumentParser` to add arguments to.\n\n* `name_prefix`: A prefix to add to the argument names. Arguments will be named `--<name-prefix>:<var-name>`. This is useful for grouping arguments.\n\n### *classmethod* `Corgy.parse_from_cmdline(parser: Optional[argparse.ArgumentParser], **parser_args)`\nParse an object of the class from command line arguments. Options:\n\n* `parser`: The `argparse.ArgumentParser` to use. If not provided or `None`, a new parser will be created.\n\n* `parser_args`: Arguments to be passed to `argparse.ArgumentParser()`. Ignored if `parser` is not `None`.\n\nThis method will return an instance of the `Corgy` subclass, with properties set to their parsed values.\n\n## `CorgyHelpFormatter`\n`CorgyHelpFormatter` is a help formatter for `argparse`, with support for colorized output. `Corgy.parse_from_cmdline` uses this formatter by default, unless a different `formatter_class` argument is provided.\n\n`CorgyHelpFormatter` can also be used independently of `Corgy`. Simply pass it as the `formatter_class` argument to `argparse.ArgumentParser()`:\n\n```python\nfrom argparse import ArgumentParser\nfrom corgy import CorgyHelpFormatter\n\nparser = ArgumentParser(formatter_class=CorgyHelpFormatter)\n...\n```\n\n### Configuration\nTo configure `CorgyHelpFormatter`, you can set a number of attributes on the class. Note that you do not need to create an instance of the class; that is done by the parser itself. The following public attributes are available:\n\n* `enable_colors`: If `None` (the default), colors are enabled if the `crayons` package is available, and the output is a tty. To explicitly enable or disable colors, set to `True` or `False`.\n\n* `color_<choices/keywords/metavars/defaults/options>`: These attributes control the colors used for various parts of the output (see below for reference). Available colors are `red`, `green`, `yellow`, `blue`, `black`, `magenta`, `cyan`, and `white`. Specifying the name in all caps will make the color bold. You can also use the special value `BOLD` to make the output bold without changing the color. The default value are `blue` for choices, `green` for keywords, `RED` for metavars, `YELLOW` for defaults, and `BOLD` for options.\n\n```text\n    -a/--arg str       help for arg ({\'a\'/\'b\'/\'c\'} default: \'a\')\n       |      |                          |            |      |\n    options  metavars                 choices      keywords defaults\n```\n\n* `output_width`: The number of columns used for the output. If `None` (the default), the current terminal width is used.\n\n* `max_help_position`: How far to the right (from the start), the help string can start from. If `None`, there is no limit. The default is `40`.\n\n* `marker_extras_<begin/end>`: The strings used to enclose the extra help text (choices, default values etc.). The defaults are `(` and `)`.\n\n* `marker_choices_<begin/end>`: The strings used to enclose the list of choices for an argument. The defaults are `{` and `}`.\n\n* `marker_choices_sep`: The string used to separate individual choices in the choice list. The default is `/`.\n',
    'author': 'Jayanth Koushik',
    'author_email': 'jnkoushik@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/jayanthkoushik/corgy',
    'packages': packages,
    'package_data': package_data,
    'extras_require': extras_require,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
