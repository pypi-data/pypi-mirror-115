{"version":3,"file":"vendors-node_modules_educational-technology-collective_etc_jupyterlab_telemetry_extension_lib-057154.30504fa79f3dee493db9.js","mappings":";;;;;;;;;;;;;AAAO;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BuD;AACZ;AACY;AAChD,gCAAgC,gEAAgB;AACvD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,kCAAkC,qDAAM;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAoD;AAChF;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,gEAAgB;AACxD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,iCAAiC,qDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,kFAAgC;AACxC;AACA;AACA,QAAQ,qFAAmC;AAC3C;AACA;AACA;AACA;AACA;AACO,kCAAkC,gEAAgB;AACzD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,qCAAqC,qDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,gEAAgB;AAC3D,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gEAAgB;AACvD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gEAAgB;AAClD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,gEAAgB;AACrD,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,SAAS;AACT,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtT+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClC2C;AACD;AACO;AAC8G;AACvG;AACjB;AACvC;AACO,2BAA2B,oDAAK;AACvC;AACA;AACA,iCAAiC,qDAAM;AACvC,gCAAgC,qDAAM;AACtC,oCAAoC,qDAAM;AAC1C,qCAAqC,qDAAM;AAC3C,kCAAkC,qDAAM;AACxC,6BAA6B,qDAAM;AACnC,+BAA+B,qDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB;AACA;AACA;AACA;AACA,uBAAuB,oDAAU;AACjC;AACA;AACA;AACA;AACA,oCAAoC,0DAAa,GAAG,8BAA8B;AAClF,wCAAwC,sDAAiB;AACzD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,yCAAyC,uDAAkB;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,0CAA0C,wDAAmB;AAC7D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,4CAA4C,0DAAqB;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,wCAAwC,sDAAiB;AACzD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,mCAAmC,iDAAY;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,sCAAsC,oDAAe;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;AC3Gf;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG,qCAAqC;AACrC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA,8CAA8C;AAC9C,kDAAkD;AAClD;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/config_supplicant.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/events.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/index.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_coursera/./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state.js"],"sourcesContent":["export class ConfigSupplicant {\n    constructor({ paths, config }) {\n        this._state = false;\n        this.enable = this.enable.bind(this);\n        this.disable = this.disable.bind(this);\n        try {\n            let state = paths.reduce((previousValue, currentValue) => {\n                return previousValue[currentValue];\n            }, config);\n            //  We need to know the value assigned to the reference path (i.e., paths); \n            //  hence, drill into the arbitrary config object in order to obtain the value.\n            if (this._state !== state) {\n                if (state === true) {\n                    setTimeout(this.enable);\n                }\n                else {\n                    setTimeout(this.disable);\n                }\n                this._state = state;\n            }\n        }\n        catch (e) {\n            setTimeout(this.enable);\n            this._state = true;\n            //  The default is for all events to be enabled; hence, we don't need to log anything here.\n        }\n    }\n}\n","import { NotebookActions } from \"@jupyterlab/notebook\";\nimport { Signal } from '@lumino/signaling';\nimport { ConfigSupplicant } from \"./config_supplicant\";\nexport class NotebookSaveEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookSaveEvent\", \"enable\"],\n            config\n        });\n        this._notebookSaved = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(context, saveState) {\n        let cell;\n        let cells;\n        let index;\n        if (saveState.match(\"completed\")) {\n            cells = [];\n            for (index = 0; index < this._notebookPanel.content.widgets.length; index++) {\n                cell = this._notebookPanel.content.widgets[index];\n                if (this._notebookPanel.content.isSelectedOrActive(cell)) {\n                    cells.push({ id: cell.model.id, index });\n                }\n            }\n            let notebookState = this._notebookState.getNotebookState();\n            this._notebookSaved.emit({\n                event_name: \"save_notebook\",\n                cells: cells,\n                notebook: notebookState.notebook,\n                seq: notebookState.seq,\n                notebook_path: this._notebookPanel.context.path\n            });\n        }\n    }\n    enable() {\n        this._notebookPanel.context.saveState.connect(this.event, this);\n    }\n    disable() {\n        this._notebookPanel.context.saveState.disconnect(this.event, this);\n    }\n    get notebookSaved() {\n        return this._notebookSaved;\n    }\n}\nexport class CellExecutionEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellExecutionEvent\", \"enable\"],\n            config\n        });\n        this._cellExecuted = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(_, args) {\n        if (args.notebook.model === this._notebook.model) {\n            let cells = [\n                {\n                    id: args.cell.model.id,\n                    index: this._notebook.widgets.findIndex((value) => value == args.cell)\n                }\n            ];\n            let notebookState = this._notebookState.getNotebookState();\n            this._cellExecuted.emit({\n                event_name: \"cell_executed\",\n                cells: cells,\n                notebook: notebookState.notebook,\n                seq: notebookState.seq,\n                notebook_path: this._notebookPanel.context.path\n            });\n        }\n    }\n    enable() {\n        NotebookActions.executed.connect(this.event, this);\n    }\n    disable() {\n        NotebookActions.executed.disconnect(this.event, this);\n    }\n    get cellExecuted() {\n        return this._cellExecuted;\n    }\n}\nexport class NotebookScrollEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookScrollEvent\", \"enable\"],\n            config\n        });\n        this._notebookScrolled = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this._timeout = 0;\n        this.event = this.event.bind(this);\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(e) {\n        e.stopPropagation();\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(() => {\n            let cells = [];\n            let cell;\n            let index;\n            let id;\n            for (index = 0; index < this._notebook.widgets.length; index++) {\n                cell = this._notebook.widgets[index];\n                let cellTop = cell.node.offsetTop;\n                let cellBottom = cell.node.offsetTop + cell.node.offsetHeight;\n                let viewTop = this._notebook.node.scrollTop;\n                let viewBottom = this._notebook.node.scrollTop + this._notebook.node.clientHeight;\n                if (cellTop > viewBottom || cellBottom < viewTop) {\n                    continue;\n                }\n                id = cell.model.id;\n                cells.push({ id, index });\n            }\n            let notebookState = this._notebookState.getNotebookState();\n            this._notebookScrolled.emit({\n                event_name: \"scroll\",\n                cells: cells,\n                notebook: notebookState.notebook,\n                seq: notebookState.seq,\n                notebook_path: this._notebookPanel.context.path\n            });\n        }, 1000);\n    }\n    enable() {\n        this._notebook.node.addEventListener(\"scroll\", this.event, false);\n    }\n    disable() {\n        this._notebook.node.removeEventListener(\"scroll\", this.event, false);\n    }\n    get notebookScrolled() {\n        return this._notebookScrolled;\n    }\n}\nexport class ActiveCellChangeEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/ActiveCellChangeEvent\", \"enable\"],\n            config\n        });\n        this._activeCellChanged = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(send, args) {\n        let cells = [\n            {\n                id: args.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == args)\n            }\n        ];\n        let notebookState = this._notebookState.getNotebookState();\n        this._activeCellChanged.emit({\n            event_name: \"active_cell_changed\",\n            cells: cells,\n            notebook: notebookState.notebook,\n            seq: notebookState.seq,\n            notebook_path: this._notebookPanel.context.path\n        });\n    }\n    enable() {\n        this._notebook.activeCellChanged.connect(this.event, this);\n    }\n    disable() {\n        this._notebook.activeCellChanged.disconnect(this.event, this);\n    }\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n}\nexport class NotebookOpenEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookOpenEvent\", \"enable\"],\n            config\n        });\n        this._notebookOpened = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this._enable = false;\n        setTimeout(this.event.bind(this));\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event() {\n        if (!this._enable) {\n            return;\n        }\n        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));\n        let notebookState = this._notebookState.getNotebookState();\n        this._notebookOpened.emit({\n            event_name: \"open_notebook\",\n            cells: cells,\n            notebook: notebookState.notebook,\n            seq: notebookState.seq,\n            notebook_path: this._notebookPanel.context.path\n        });\n    }\n    enable() {\n        this._enable = true;\n    }\n    disable() {\n        this._enable = false;\n    }\n    get notebookOpened() {\n        return this._notebookOpened;\n    }\n}\nexport class CellAddEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellAddEvent\", \"enable\"],\n            config\n        });\n        this._cellAdded = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(sender, args) {\n        if (args.type == \"add\") {\n            let cells = [{ id: args.newValues[0].id, index: args.newIndex }];\n            let notebookState = this._notebookState.getNotebookState();\n            this._cellAdded.emit({\n                event_name: \"add_cell\",\n                cells: cells,\n                notebook: notebookState.notebook,\n                seq: notebookState.seq,\n                notebook_path: this._notebookPanel.context.path\n            });\n        }\n    }\n    enable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);\n    }\n    disable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);\n    }\n    get cellAdded() {\n        return this._cellAdded;\n    }\n}\nexport class CellRemoveEvent extends ConfigSupplicant {\n    constructor({ notebookState, notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellRemoveEvent\", \"enable\"],\n            config\n        });\n        this._cellRemoved = new Signal(this);\n        this._notebookState = notebookState;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(sender, args) {\n        if (args.type == \"remove\") {\n            let cells = [{ id: args.oldValues[0].id, index: args.oldIndex }];\n            let notebookState = this._notebookState.getNotebookState();\n            this._cellRemoved.emit({\n                event_name: \"remove_cell\",\n                cells: cells,\n                notebook: notebookState.notebook,\n                seq: notebookState.seq,\n                notebook_path: this._notebookPanel.context.path\n            });\n        }\n    }\n    enable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);\n    }\n    disable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);\n    }\n    get cellRemoved() {\n        return this._cellRemoved;\n    }\n}\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-extension', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { Signal } from '@lumino/signaling';\nimport { Token } from '@lumino/coreutils';\nimport { NotebookState } from \"./notebook_state\";\nimport { NotebookSaveEvent, CellExecutionEvent, NotebookScrollEvent, ActiveCellChangeEvent, NotebookOpenEvent, CellAddEvent, CellRemoveEvent } from \"./events\";\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { requestAPI } from \"./handler\";\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_extension:plugin';\nexport const INotebookEvent = new Token(PLUGIN_ID);\nclass SignalMuxer {\n    constructor() {\n        this.notebookSaved = new Signal(this);\n        this.cellExecuted = new Signal(this);\n        this.notebookScrolled = new Signal(this);\n        this.activeCellChanged = new Signal(this);\n        this.notebookOpened = new Signal(this);\n        this.cellAdded = new Signal(this);\n        this.cellRemoved = new Signal(this);\n    }\n}\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_extension extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: INotebookEvent,\n    requires: [\n        INotebookTracker\n    ],\n    activate: async (app, notebookTracker) => {\n        console.log('JupyterLab extension @educational-technology-collective/etc_jupyterlab_telemetry_extension is activated!');\n        let signalMuxer = new SignalMuxer();\n        let response = requestAPI(\"config\");\n        notebookTracker.widgetAdded.connect(async (sender, notebookPanel) => {\n            await notebookPanel.revealed;\n            await notebookPanel.sessionContext.ready;\n            let config = await response;\n            let notebookState = new NotebookState({ notebookPanel: notebookPanel });\n            let notebookSaveEvent = new NotebookSaveEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            notebookSaveEvent.notebookSaved.connect((sender, args) => {\n                signalMuxer.notebookSaved.emit(args);\n            });\n            let cellExecutionEvent = new CellExecutionEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            cellExecutionEvent.cellExecuted.connect((sender, args) => {\n                signalMuxer.cellExecuted.emit(args);\n            });\n            let notebookScrollEvent = new NotebookScrollEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            notebookScrollEvent.notebookScrolled.connect((sender, args) => {\n                signalMuxer.notebookScrolled.emit(args);\n            });\n            let activeCellChangeEvent = new ActiveCellChangeEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            activeCellChangeEvent.activeCellChanged.connect((sender, args) => {\n                signalMuxer.activeCellChanged.emit(args);\n            });\n            let notebookOpenEvent = new NotebookOpenEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            notebookOpenEvent.notebookOpened.connect((sender, args) => {\n                signalMuxer.notebookOpened.emit(args);\n            });\n            let cellAddEvent = new CellAddEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            cellAddEvent.cellAdded.connect((sender, args) => {\n                signalMuxer.cellAdded.emit(args);\n            });\n            let cellRemoveEvent = new CellRemoveEvent({\n                notebookState: notebookState,\n                notebookPanel: notebookPanel,\n                config: config\n            });\n            cellRemoveEvent.cellRemoved.connect((sender, args) => {\n                signalMuxer.cellRemoved.emit(args);\n            });\n        });\n        // // TEST\n        // signalMuxer.activeCellChanged.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.cellAdded.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.cellExecuted.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.cellRemoved.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.notebookOpened.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.notebookSaved.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // signalMuxer.notebookScrolled.connect((sender: SignalMuxer, args: any) => console.log(\"etc_jupyterlab_telemetry_extension\", args));\n        // // TEST\n        return signalMuxer;\n    }\n};\nexport default plugin;\n","export class NotebookState {\n    constructor({ notebookPanel }) {\n        var _a;\n        this._notebook = notebookPanel.content;\n        this._cellState = new WeakMap();\n        this._seq = 0;\n        this.updateCellState();\n        //  The notebook loaded; hence, update the cell state.\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect((sender, args) => {\n            if (args.type == \"add\" || args.type == \"set\") {\n                this.updateCellState();\n                //  A cell was added; hence, update the cell state.\n            }\n        }, this);\n    }\n    updateCellState() {\n        this._notebook.widgets.forEach((cell) => {\n            if (!this._cellState.has(cell)) {\n                this._cellState.set(cell, { changed: true, output: this.createCellOutput(cell) });\n                //  It's a new cell; hence, the changed state is set to true.\n                ////  This is a new cell; hence, add handlers that check for changes in the inputs and outputs.\n                cell.inputArea.model.value.changed.connect((sender, args) => {\n                    let state = this._cellState.get(cell);\n                    if (state !== undefined) {\n                        state.changed = true;\n                        //  The input area changed; hence, the changed state is set to true.\n                    }\n                });\n                if (cell.model.type == \"code\") {\n                    cell.model.outputs.changed.connect((sender, args) => {\n                        if (args.type == \"add\") {\n                            //  An output has been added to the cell; hence, compare the current state with the new state.\n                            let state = this._cellState.get(cell);\n                            if (state !== undefined) {\n                                let output = this.createCellOutput(cell);\n                                if (output !== (state === null || state === void 0 ? void 0 : state.output)) {\n                                    //  The output has changed; hence, set changed to true and update the output state.\n                                    state.changed = true;\n                                    state.output = output;\n                                }\n                                else {\n                                    //  The output hasn't changed; hence, leave the state as is.\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createCellOutput(cell) {\n        //  Combine the cell outputs into a string in order to check for changes.\n        let output = \"\";\n        if (cell.model.type == \"code\") {\n            let outputs = cell.model.outputs;\n            for (let index = 0; index < outputs.length; index++) {\n                for (let key of Object.keys(outputs.get(index).data).sort()) {\n                    output = output + JSON.stringify(outputs.get(index).data[key]);\n                }\n            }\n            return output;\n        }\n        return \"\";\n    }\n    getNotebookState() {\n        var _a;\n        let nbFormatNotebook = (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.toJSON();\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState === undefined) {\n                throw new Error(`The cell at index ${index} is not tracked.`);\n            }\n            if ((cellState === null || cellState === void 0 ? void 0 : cellState.changed) === false) {\n                //  The cell has not changed; hence, the notebook format cell will contain just its id.\n                nbFormatNotebook.cells[index] = { id: this._notebook.widgets[index].model.id };\n            }\n        }\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState !== undefined) {\n                cellState.changed = false;\n            }\n            //  The cell state is going to be captured; hence, set the state to not changed.\n            //  We need to be certain that all the cells were processed prior to making any changes to their state;\n            //  hence, this operation is done in a loop separate from the loop above.\n        }\n        let state = {\n            notebook: nbFormatNotebook,\n            seq: this._seq\n        };\n        this._seq = this._seq + 1;\n        //  We've made changes to the state at this point; \n        //  hence, it's really important that nothing throws between now and recording the message.\n        //  We need all the messages in order to reconstruct the Notebook at each event;\n        //  hence, we need all the messages in order to reconstruct the Notebook at each event. :-)\n        return state;\n    }\n}\n"],"names":[],"sourceRoot":""}