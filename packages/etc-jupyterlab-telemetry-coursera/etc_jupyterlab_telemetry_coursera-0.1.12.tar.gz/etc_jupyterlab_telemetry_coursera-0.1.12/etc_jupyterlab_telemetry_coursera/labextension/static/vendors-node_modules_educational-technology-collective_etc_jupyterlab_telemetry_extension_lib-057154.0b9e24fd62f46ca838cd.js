"use strict";
(self["webpackChunk_educational_technology_collective_etc_jupyterlab_telemetry_coursera"] = self["webpackChunk_educational_technology_collective_etc_jupyterlab_telemetry_coursera"] || []).push([["vendors-node_modules_educational-technology-collective_etc_jupyterlab_telemetry_extension_lib-057154"],{

/***/ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/config_supplicant.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/config_supplicant.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigSupplicant": () => (/* binding */ ConfigSupplicant)
/* harmony export */ });
class ConfigSupplicant {
    constructor({ paths, config }) {
        this.enable = this.enable.bind(this);
        this.disable = this.disable.bind(this);
        try {
            if (!config) {
                throw new Error();
            }
            let state = paths.reduce((previousValue, currentValue) => {
                return previousValue[currentValue];
            }, config);
            //  We need to know the value assigned to the reference path (i.e., paths); 
            //  hence, drill into the arbitrary config object in order to obtain the value.    
            if (state === false) {
                setTimeout(this.disable);
            }
            else if (state === true) {
                setTimeout(this.enable);
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            setTimeout(this.enable);
            //  The default is for all events to be enabled; hence, we don't need to log anything here.
        }
    }
}


/***/ }),

/***/ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/events.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/events.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookSaveEvent": () => (/* binding */ NotebookSaveEvent),
/* harmony export */   "CellExecutionEvent": () => (/* binding */ CellExecutionEvent),
/* harmony export */   "NotebookScrollEvent": () => (/* binding */ NotebookScrollEvent),
/* harmony export */   "ActiveCellChangeEvent": () => (/* binding */ ActiveCellChangeEvent),
/* harmony export */   "NotebookOpenEvent": () => (/* binding */ NotebookOpenEvent),
/* harmony export */   "CellAddEvent": () => (/* binding */ CellAddEvent),
/* harmony export */   "CellRemoveEvent": () => (/* binding */ CellRemoveEvent)
/* harmony export */ });
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook");
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _config_supplicant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config_supplicant */ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/config_supplicant.js");



class NotebookSaveEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/NotebookSaveEvent", "enable"],
            config
        });
        this._notebookSaved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(context, saveState) {
        let cell;
        let cells;
        let index;
        if (saveState.match("completed")) {
            cells = [];
            for (index = 0; index < this._notebookPanel.content.widgets.length; index++) {
                cell = this._notebookPanel.content.widgets[index];
                if (this._notebookPanel.content.isSelectedOrActive(cell)) {
                    cells.push({ id: cell.model.id, index });
                }
            }
            let notebookState = this._notebookState.getNotebookState();
            this._notebookSaved.emit({
                event_name: "save_notebook",
                cells: cells,
                notebook: notebookState.notebook,
                session_id: notebookState.session_id,
                seq: notebookState.seq,
                notebook_path: this._notebookPanel.context.path
            });
        }
    }
    enable() {
        this._notebookPanel.context.saveState.connect(this.event, this);
    }
    disable() {
        this._notebookPanel.context.saveState.disconnect(this.event, this);
    }
    get notebookSaved() {
        return this._notebookSaved;
    }
}
class CellExecutionEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/CellExecutionEvent", "enable"],
            config
        });
        this._cellExecuted = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(_, args) {
        if (args.notebook.model === this._notebook.model) {
            let cells = [
                {
                    id: args.cell.model.id,
                    index: this._notebook.widgets.findIndex((value) => value == args.cell)
                }
            ];
            let notebookState = this._notebookState.getNotebookState();
            this._cellExecuted.emit({
                event_name: "cell_executed",
                cells: cells,
                notebook: notebookState.notebook,
                session_id: notebookState.session_id,
                seq: notebookState.seq,
                notebook_path: this._notebookPanel.context.path
            });
        }
    }
    enable() {
        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.NotebookActions.executed.connect(this.event, this);
    }
    disable() {
        _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.NotebookActions.executed.disconnect(this.event, this);
    }
    get cellExecuted() {
        return this._cellExecuted;
    }
}
class NotebookScrollEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/NotebookScrollEvent", "enable"],
            config
        });
        this._notebookScrolled = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        this._timeout = 0;
        this.event = this.event.bind(this);
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(e) {
        e.stopPropagation();
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => {
            let cells = [];
            let cell;
            let index;
            let id;
            for (index = 0; index < this._notebook.widgets.length; index++) {
                cell = this._notebook.widgets[index];
                let cellTop = cell.node.offsetTop;
                let cellBottom = cell.node.offsetTop + cell.node.offsetHeight;
                let viewTop = this._notebook.node.scrollTop;
                let viewBottom = this._notebook.node.scrollTop + this._notebook.node.clientHeight;
                if (cellTop > viewBottom || cellBottom < viewTop) {
                    continue;
                }
                id = cell.model.id;
                cells.push({ id, index });
            }
            let notebookState = this._notebookState.getNotebookState();
            this._notebookScrolled.emit({
                event_name: "scroll",
                cells: cells,
                notebook: notebookState.notebook,
                session_id: notebookState.session_id,
                seq: notebookState.seq,
                notebook_path: this._notebookPanel.context.path
            });
        }, 1000);
    }
    enable() {
        this._notebook.node.addEventListener("scroll", this.event, false);
    }
    disable() {
        this._notebook.node.removeEventListener("scroll", this.event, false);
    }
    get notebookScrolled() {
        return this._notebookScrolled;
    }
}
class ActiveCellChangeEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/ActiveCellChangeEvent", "enable"],
            config
        });
        this._activeCellChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(send, args) {
        let cells = [
            {
                id: args.model.id,
                index: this._notebook.widgets.findIndex((value) => value == args)
            }
        ];
        let notebookState = this._notebookState.getNotebookState();
        this._activeCellChanged.emit({
            event_name: "active_cell_changed",
            cells: cells,
            notebook: notebookState.notebook,
            session_id: notebookState.session_id,
            seq: notebookState.seq,
            notebook_path: this._notebookPanel.context.path
        });
    }
    enable() {
        this._notebook.activeCellChanged.connect(this.event, this);
    }
    disable() {
        this._notebook.activeCellChanged.disconnect(this.event, this);
    }
    get activeCellChanged() {
        return this._activeCellChanged;
    }
}
class NotebookOpenEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/NotebookOpenEvent", "enable"],
            config
        });
        this._notebookOpened = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        this._enable = false;
        setTimeout(this.event.bind(this));
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event() {
        if (!this._enable) {
            return;
        }
        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));
        let notebookState = this._notebookState.getNotebookState();
        this._notebookOpened.emit({
            event_name: "open_notebook",
            cells: cells,
            notebook: notebookState.notebook,
            session_id: notebookState.session_id,
            seq: notebookState.seq,
            notebook_path: this._notebookPanel.context.path
        });
    }
    enable() {
        this._enable = true;
    }
    disable() {
        this._enable = false;
    }
    get notebookOpened() {
        return this._notebookOpened;
    }
}
class CellAddEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/CellAddEvent", "enable"],
            config
        });
        this._cellAdded = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(sender, args) {
        if (args.type == "add") {
            let cells = [{ id: args.newValues[0].id, index: args.newIndex }];
            let notebookState = this._notebookState.getNotebookState();
            this._cellAdded.emit({
                event_name: "add_cell",
                cells: cells,
                notebook: notebookState.notebook,
                session_id: notebookState.session_id,
                seq: notebookState.seq,
                notebook_path: this._notebookPanel.context.path
            });
        }
    }
    enable() {
        var _a;
        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);
    }
    disable() {
        var _a;
        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);
    }
    get cellAdded() {
        return this._cellAdded;
    }
}
class CellRemoveEvent extends _config_supplicant__WEBPACK_IMPORTED_MODULE_2__.ConfigSupplicant {
    constructor({ notebookState, notebookPanel, config }) {
        super({
            paths: ["mentoracademy.org/schemas/events/1.0.0/CellRemoveEvent", "enable"],
            config
        });
        this._cellRemoved = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._notebookState = notebookState;
        this._notebookPanel = notebookPanel;
        this._notebook = notebookPanel.content;
        notebookPanel.disposed.connect(this.dispose, this);
    }
    dispose() {
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectAll(this);
    }
    event(sender, args) {
        if (args.type == "remove") {
            let cells = [{ id: args.oldValues[0].id, index: args.oldIndex }];
            let notebookState = this._notebookState.getNotebookState();
            this._cellRemoved.emit({
                event_name: "remove_cell",
                cells: cells,
                notebook: notebookState.notebook,
                session_id: notebookState.session_id,
                seq: notebookState.seq,
                notebook_path: this._notebookPanel.context.path
            });
        }
    }
    enable() {
        var _a;
        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);
    }
    disable() {
        var _a;
        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);
    }
    get cellRemoved() {
        return this._cellRemoved;
    }
}


/***/ }),

/***/ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/handler.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/handler.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "requestAPI": () => (/* binding */ requestAPI)
/* harmony export */ });
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/services */ "webpack/sharing/consume/default/@jupyterlab/services");
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__);


/**
 * Call the API extension
 *
 * @param endPoint API REST end point for the extension
 * @param init Initial values for the request
 * @returns The response body interpreted as JSON
 */
async function requestAPI(endPoint = '', init = {}) {
    // Make request to Jupyter API
    const settings = _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__.ServerConnection.makeSettings();
    const requestUrl = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-extension', // API Namespace
    endPoint);
    let response;
    try {
        response = await _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__.ServerConnection.makeRequest(requestUrl, init, settings);
    }
    catch (error) {
        throw new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__.ServerConnection.NetworkError(error);
    }
    let data = await response.text();
    if (data.length > 0) {
        try {
            data = JSON.parse(data);
        }
        catch (error) {
            console.log('Not a JSON response body.', response);
        }
    }
    if (!response.ok) {
        throw new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_1__.ServerConnection.ResponseError(response, data.message || data);
    }
    return data;
}


/***/ }),

/***/ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookSaveEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.NotebookSaveEvent),
/* harmony export */   "CellExecutionEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.CellExecutionEvent),
/* harmony export */   "NotebookScrollEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.NotebookScrollEvent),
/* harmony export */   "ActiveCellChangeEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.ActiveCellChangeEvent),
/* harmony export */   "NotebookOpenEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.NotebookOpenEvent),
/* harmony export */   "CellAddEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.CellAddEvent),
/* harmony export */   "CellRemoveEvent": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.CellRemoveEvent),
/* harmony export */   "IETCJupyterLabTelemetry": () => (/* binding */ IETCJupyterLabTelemetry),
/* harmony export */   "NotebookEventLibrary": () => (/* binding */ NotebookEventLibrary),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _notebook_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notebook_state */ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/events.js");
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook");
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handler */ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/handler.js");






const PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_extension:plugin';
const IETCJupyterLabTelemetry = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token(PLUGIN_ID);
class NotebookEventLibrary {
    constructor({ notebookPanel }) {
        let notebookState = new _notebook_state__WEBPACK_IMPORTED_MODULE_3__.NotebookState({ notebookPanel: notebookPanel });
        this.notebookOpenEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.NotebookOpenEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.notebookSaveEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.NotebookSaveEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.cellExecutionEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.CellExecutionEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.notebookScrollEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.NotebookScrollEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.activeCellChangeEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.ActiveCellChangeEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.cellAddEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.CellAddEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
        this.cellRemoveEvent = new _events__WEBPACK_IMPORTED_MODULE_1__.CellRemoveEvent({
            notebookState: notebookState,
            notebookPanel: notebookPanel,
            config: NotebookEventLibrary._config
        });
    }
}
/**
 * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_extension extension.
 */
const plugin = {
    id: PLUGIN_ID,
    autoStart: true,
    provides: IETCJupyterLabTelemetry,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_2__.INotebookTracker],
    activate: async (app, notebookTracker) => {
        console.log('JupyterLab extension @educational-technology-collective/etc_jupyterlab_telemetry_extension is activated!');
        let config = null;
        try {
            config = await (0,_handler__WEBPACK_IMPORTED_MODULE_4__.requestAPI)("config");
        }
        catch (e) {
            console.error(e);
        }
        NotebookEventLibrary._config = config;
        let etcJupyterLabTelemetry = {
            NotebookEventLibrary: NotebookEventLibrary
        };
        // // TEST
        // notebookTracker.widgetAdded.connect(async (sender: INotebookTracker, notebookPanel: NotebookPanel) => {
        //   await notebookPanel.revealed;
        //   await notebookPanel.sessionContext.ready;
        //   let notebookEvent = new etcJupyterLabTelemetry.NotebookEventLibrary({ notebookPanel });
        //   notebookEvent.notebookOpenEvent.notebookOpened.connect((sender: NotebookOpenEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args));
        //   notebookEvent.notebookSaveEvent.notebookSaved.connect((sender: NotebookSaveEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args));
        //   notebookEvent.activeCellChangeEvent.activeCellChanged.connect((sender: ActiveCellChangeEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args))
        //   notebookEvent.cellAddEvent.cellAdded.connect((sender: CellAddEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args))
        //   notebookEvent.cellRemoveEvent.cellRemoved.connect((sender: CellRemoveEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args))
        //   notebookEvent.notebookScrollEvent.notebookScrolled.connect((sender: NotebookScrollEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args))
        //   notebookEvent.cellExecutionEvent.cellExecuted.connect((sender: CellExecutionEvent, args: any) => console.log("etc_jupyterlab_telemetry_extension", args))
        // });
        // // TEST
        return etcJupyterLabTelemetry;
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);


/***/ }),

/***/ "./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@educational-technology-collective/etc_jupyterlab_telemetry_extension/lib/notebook_state.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookState": () => (/* binding */ NotebookState)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);

class NotebookState {
    constructor({ notebookPanel }) {
        var _a;
        this._notebook = notebookPanel.content;
        this._cellState = new WeakMap();
        this._seq = 0;
        this._session_id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4();
        this.updateCellState();
        //  The notebook loaded; hence, update the cell state.
        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect((sender, args) => {
            if (args.type == "add" || args.type == "set") {
                this.updateCellState();
                //  A cell was added; hence, update the cell state.
            }
        }, this);
    }
    updateCellState() {
        this._notebook.widgets.forEach((cell) => {
            if (!this._cellState.has(cell)) {
                this._cellState.set(cell, { changed: true, output: this.createCellOutput(cell) });
                //  It's a new cell; hence, the changed state is set to true.
                ////  This is a new cell; hence, add handlers that check for changes in the inputs and outputs.
                cell.inputArea.model.value.changed.connect((sender, args) => {
                    let state = this._cellState.get(cell);
                    if (state !== undefined) {
                        state.changed = true;
                        //  The input area changed; hence, the changed state is set to true.
                    }
                });
                if (cell.model.type == "code") {
                    cell.model.outputs.changed.connect((sender, args) => {
                        if (args.type == "add") {
                            //  An output has been added to the cell; hence, compare the current state with the new state.
                            let state = this._cellState.get(cell);
                            if (state !== undefined) {
                                let output = this.createCellOutput(cell);
                                if (output !== (state === null || state === void 0 ? void 0 : state.output)) {
                                    //  The output has changed; hence, set changed to true and update the output state.
                                    state.changed = true;
                                    state.output = output;
                                }
                                else {
                                    //  The output hasn't changed; hence, leave the state as is.
                                }
                            }
                        }
                    });
                }
            }
        });
    }
    createCellOutput(cell) {
        //  Combine the cell outputs into a string in order to check for changes.
        let output = "";
        if (cell.model.type == "code") {
            let outputs = cell.model.outputs;
            for (let index = 0; index < outputs.length; index++) {
                for (let key of Object.keys(outputs.get(index).data).sort()) {
                    output = output + JSON.stringify(outputs.get(index).data[key]);
                }
            }
            return output;
        }
        return "";
    }
    getNotebookState() {
        var _a;
        let nbFormatNotebook = (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.toJSON();
        for (let index = 0; index < this._notebook.widgets.length; index++) {
            let cell = this._notebook.widgets[index];
            let cellState = this._cellState.get(cell);
            if (cellState === undefined) {
                throw new Error(`The cell at index ${index} is not tracked.`);
            }
            if ((cellState === null || cellState === void 0 ? void 0 : cellState.changed) === false) {
                //  The cell has not changed; hence, the notebook format cell will contain just its id.
                nbFormatNotebook.cells[index] = { id: this._notebook.widgets[index].model.id };
            }
        }
        for (let index = 0; index < this._notebook.widgets.length; index++) {
            let cell = this._notebook.widgets[index];
            let cellState = this._cellState.get(cell);
            if (cellState !== undefined) {
                cellState.changed = false;
            }
            //  The cell state is going to be captured; hence, set the state to not changed.
            //  We need to be certain that all the cells were processed prior to making any changes to their state;
            //  hence, this operation is done in a loop separate from the loop above.
        }
        let state = {
            session_id: this._session_id,
            seq: this._seq,
            notebook: nbFormatNotebook
        };
        this._seq = this._seq + 1;
        //  We've made changes to the state at this point; 
        //  hence, it's really important that nothing throws between now and recording the message.
        //  We need all the messages in order to reconstruct the Notebook at each event;
        //  hence, we need all the messages in order to reconstruct the Notebook at each event. :-)
        return state;
    }
}


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_educational-technology-collective_etc_jupyterlab_telemetry_extension_lib-057154.0b9e24fd62f46ca838cd.js.map