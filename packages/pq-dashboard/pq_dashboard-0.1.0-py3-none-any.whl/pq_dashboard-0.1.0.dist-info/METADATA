Metadata-Version: 2.1
Name: pq-dashboard
Version: 0.1.0
Summary: Web dashboard and CLI utility for managing PQ queues
Home-page: https://github.com/MisterKeefe/pq-dashboard
License: MIT
Keywords: pq,dashboard,postgres
Author: Tom Keefe
Author-email: 8655118+MisterKeefe@users.noreply.github.com
Requires-Python: >=3.7,<4.0
Classifier: Environment :: Console
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: JavaScript
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: SQL
Classifier: Topic :: Database :: Front-Ends
Requires-Dist: aiofiles (>=0.7.0,<0.8.0)
Requires-Dist: fastapi (>=0.67.0,<0.68.0)
Requires-Dist: psycopg2 (>=2.9.1,<3.0.0)
Requires-Dist: pydantic (>=1.8.2,<2.0.0)
Requires-Dist: pytest-postgresql (>=3.1.1,<4.0.0)
Requires-Dist: uvicorn[standard] (>=0.14.0,<0.15.0)
Project-URL: Repository, https://github.com/MisterKeefe/pq-dashboard
Description-Content-Type: text/markdown

# pq-dashboard

`pq-dashboard` is a general purpose, lightweight, [FastAPI](https://fastapi.tiangolo.com/)-based web front-end and CLI tool to monitor your [PQ](https://github.com/malthe/pq/) queues and tasks.

[Sound familiar?](https://github.com/Parallels/rq-dashboard#introduction) Basically, `pq-dashboard` is to `pq` as `rq-dashboard` is to `rq`.

## Quickstart

### Installing from PyPI

`python -m pip install pq-dashboard`

Then run `pq-dashboard` with no arguments, which will start the server.

```
$ pq-dashboard
```

You may need to configure environment variables (see below) to connect to the PostGRES server where your `pq` queues are stored.

### Using docker

`pq-dashboard` can run as a docker container. The image can be built with `./scripts/build-image.sh`. This creates the `pq-dashboard:v0` image.

The easiest way to run locally is to use the host network:

```
docker run --net=host pq-dashboard:v0
```

The app will then be available on host port `9182` by default. In production, you may want to configure networking differently.

An environment file can be passed to `docker` like this:

```
docker run --env-file=.pq-dash.env --net=host pq-dashboard:v0
```

### CLI tool usage

The `pq-dashboard` command can also be used as a CLI tool for basic queue management.

```
$ pq-dashboard stats|cleanup|cancel-all <comma-separated list of queue names>
```

For more details, see the help messages on all the commands

## Environment variables

`pq-dashboard` will read config from environment variables prefixed with `PQ_DASH`.

| Variable                   | Default value | Explanation                                     |
| -------------------------- | ------------- | ----------------------------------------------- |
| `PQ_DASH_PGHOST`           | `localhost`   | Host the PostgreSQL server is running on.       |
| `PQ_DASH_PGPORT`           | `5432`        | Port the PostgreSQL server is running on.       |
| `PQ_DASHBOARD_PGUSER`      | `postgres`    | PostgreSQL user name to connect as.             |
| `PQ_DASHBOARD_PGPASSWORD`  | `postgres`    | Password for the PostgreSQL user.               |
| `PQ_DASHBOARD_DATABASE`    | `postgres`    | PostgreSQL database name containing queue table |
| `PQ_DASHBOARD_QUEUE_TABLE` | `queue`       | Name of queue table containing items            |

Alternatively, these variables can be stored in a plaintext `.pq-dash.env` file. Enviroment variables
will take precedence over the `.env` file.

## Development

To install dev dependencies, use:

```
poetry install
```

Then, install the [`pre-commit`](https://pre-commit.com/) hook:

```
pre-commit install
```

This ensures all commits will be linted properly.

To run the dev frontend, from the `pq_dashboard/frontend` directory run:

```
npm run dev
```

then to start the backend:

```
uvicorn pq_dashboard.main:app --reload --port 9182
```

The backend statically serves the frontend, but you will need to refresh the page to see your changes in the frontend code.

