# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['middletools']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'middletools',
    'version': '0.1.2',
    'description': 'This python library allows you integrate async-await middleware-based system to your project',
    'long_description': '# Middletools\n[![Coverage Status](https://coveralls.io/repos/github/deknowny/middletools/badge.svg)](https://coveralls.io/github/deknowny/middletools)\n![Supported python version](https://img.shields.io/pypi/pyversions/middletools)\n![PyPI package version](https://img.shields.io/pypi/v/middletools)\n![Downloads](https://img.shields.io/pypi/dm/middletools)\n\n\nThis is a python library that allows you to integrate middlewares-based system to your project. It contains base tools for creating and running middlewares with `async-await` style\n\n## Installation\n### PyPI\n```shell\npython -m pip install middletools\n```\n### GitHub\n```shell\npython -m pip install https://github.com/deknowny/middlewares/archive/main.zip\n```\n\n## Usage\nThe main idea is give an ability just passing the middlewares and `inbox`/`outbox` payload values in a few methods instead of running and saving middlewares state by hand\n\nStandard case: a function runs RESTful API routers and requires a middleware that checks\na header in client\'s request\n\n***\nThere are 2 endpoints for an abstract `GET` and `POST` methods\n```python\n# Some abstract router\n@router.get("/")\nasync def route_get(request):\n    return 200, {"response": "some content"}\n\n\n@router.post("/")\nasync def route_post(request):\n    return 201, {"response": "ok"}\n\n```\n\nIn the core of web framework you used a function like this that just call all routers\n\n```python\nclass Router:\n    ...\n    ...\n    \n    async def call_routers(self, request):\n        for router in self.routers:\n            ... # Pass request to routers and check it matched\n```\n\n`middlewares` library allows you easy integrate middleware system to your `call_routers`\n***\n### Create middleware function\n```python\nimport middletools\n\n...\n...\n\n# Adding a middleware handler to an abstract \n@router.add_middleware\nasync def my_middleware(\n    request: SomeRequest, call_next: middletools.types.CallNext\n) -> SomeResponse:\n    # Just check if header exists, id not set the default value\n    if "X-Required-Header" not in request.headers:\n        request.header["X-Required-Header"] = "default"\n    response = await call_next()\n    return response\n```\nHere we add a header to client request if clint didn\'t do it. Then `await call_next()` give control to other middlewares or to our `call_routers` handler and response from this is the value `call_next()` returns\n***\n`call_routers` should looks like this \n```python\nimport typing\n\nimport middletools\n\n\nclass Router:\n    # You can use generics to describe middleware hand;er\n    middlewares: typing.List[\n        middletools.types.MiddlewareHandler[\n            SomeRequest, SomeResponse\n        ]\n    ]\n    ...\n    ...\n\n    async def call_routers(self, request):\n        read_afterwords = await middletools.read_forewords(\n            *self.middlewares, inbox_value=request\n        )\n        for router in self.routers:\n            ... # Pass request to routers and check it matched\n            response = ...\n            await read_afterwords(response)\n            break\n        \n```\n`middlewares.read_forewords` run middlewares until every one of them give control with `await call_next()`.\nWhen we do all our stuff and get the router response we can call `await read_afterwords(response)` and run all middlewares completely.\n\n### Notes\nIf a middleware doesn\'t call `call_next()` it raises `middlewares.CallNextNotUsedError`. It means that the middleware forcibly decline middlewares handlers and response should be sent immediately without routers running. `call_routers` should looks like this:\n```python\nimport middletools\n\n\nasync def call_routers(self, request):\n    try:\n        read_afterwords = await middletools.read_forewords(\n            *self.middlewares, inbox_value=request\n        )\n        for router in self.routers:\n            ... # Pass request to routers and check it matched\n            response = ...\n            await read_afterwords(response)\n            return response\n    except middletools.CallNextNotUsedError:\n        return SomeBadResponseBecauseNotRouted(400, "Require a header!")\n    \n```\n***\nIf a middleware doesn\'t return anything, middlewares dispatching declined forcibly too but after routers handled. (Return nothing means there isn\'t any `return` or `return None` used). It raises `middlewares.NothingReturnedError`\n```python\nimport middletools\n\n\nasync def call_routers(self, request):\n    try:\n        read_afterwords = await middletools.read_forewords(\n            *self.middlewares, inbox_value=request\n        )\n        for router in self.routers:\n            ... # Pass request to routers and check it matched\n            response = ...\n            await read_afterwords(response)\n            return response\n    except middletools.CallNextNotUsedError:\n        return SomeBadResponseBecauseNotRouted(400, "Require a header!")\n    except middletools.NothingReturnedError:\n        return SomeBadResponseBecauseMiddlewareDntReturnResponse(\n            500, "Oops, internal server error"\n        )\n```\n',
    'author': 'deknowny',
    'author_email': 'deknowny@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/deknowny/middletools',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
